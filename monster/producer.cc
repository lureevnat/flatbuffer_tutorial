/*
flatc -o generated  --gen-all -c monster.fbs  
g++ -g -O0 producer.cc -Igenerated -I/local/tools/installs/oss/flatbuffers/23.3.3/include/ -L/local/tools/installs/oss/flatbuffers/23.3.3/lib64/ -lflatbuffers -o producercc && ./producercc

*/
#include<iostream>
#include <fstream>
#include<string>

using namespace std;


#include "monster_generated.h" // This was generated by `flatc`
#include "flatbuffers/flatbuffers.h" // The runtime library for C++
// using namespace flatbuffers;
// Simplifies naming in the following examples.
using namespace MyGame::Sample; // Specified in the schema.

int main(){
    // Construct a Builder with 1024 byte backing array.
    flatbuffers::FlatBufferBuilder builder(1024);

    flatbuffers::Offset<flatbuffers::String> weapon_one_name = builder.CreateString("Sword");
    flatbuffers::Offset<flatbuffers::String> weapon_two_name = builder.CreateString("Axe");

    short weapon_one_damage = 3;
    short weapon_two_damage = 5;

    // Use the `CreateWeapon()` shortcut to create Weapons with all the fields
    // set.
    flatbuffers::Offset<Weapon> sword =
        CreateWeapon(builder, weapon_one_name, weapon_one_damage);
    flatbuffers::Offset<Weapon> axe =
        CreateWeapon(builder, weapon_two_name, weapon_two_damage);


    // Create a std::vector of the offsets we had previous made.
    std::vector<flatbuffers::Offset<Weapon>> weapons_vector;
    weapons_vector.push_back(sword);
    weapons_vector.push_back(axe);

    // Then serialize that std::vector into the buffer and again get an Offset
    // to that vector. Use `auto` here since the full type is long, and it just
    // a "typed" number.
    auto weapons = builder.CreateVector(weapons_vector);


    // Create a `vector` representing the inventory of the Orc. Each number
    // could correspond to an item that can be claimed after he is slain.
    unsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    flatbuffers::Offset<flatbuffers::Vector<unsigned char>> inventory =
        builder.CreateVector(treasure, 10);

    // Construct an array of two `Vec3` structs.
    Vec3 points[] = { Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f) };

    // // Serialize it as a vector of structs.
    // flatbuffers::Offset<flatbuffers::Vector<Vec3>> path =
    //     builder.CreateVectorOfStructs(points, 2);


    // Create the remaining data needed for the Monster.
    auto name = builder.CreateString("Orc");

    // Create the position struct
    auto position = Vec3(1.0f, 2.0f, 3.0f);

    // Set his hit points to 300 and his mana to 150.
    int hp = 300;
    int mana = 150;

    // Finally, create the monster using the `CreateMonster` helper function
    // to set all fields.
    //
    // Here we set the union field by using the `.Union()` method of the
    // `Offset<Weapon>` axe we already serialized above. We just have to specify
    // which type of object we put in the union, and do that with the
    // auto-generated `Equipment_Weapon` enum.
    flatbuffers::Offset<Monster> orc =
        CreateMonster(builder, &position, mana, hp, name, inventory,
                    Color_Red, weapons, Equipment_Weapon, axe.Union()
                    );

    // Call `Finish()` to instruct the builder that this monster is complete.
    // You could also call `FinishMonsterBuffer(builder, orc);`
    builder.Finish(orc);

    // This must be called after `Finish()`.
    uint8_t *buf = builder.GetBufferPointer();

    // Returns the size of the buffer that `GetBufferPointer()` points to.
    int size = builder.GetSize();


    std::ofstream out("monster.bin", std::ios::binary);
    if (!out) {
        std::cerr << "Error opening file for writing\n";
        return 1;
    }

    // Write buffer to file
    out.write(reinterpret_cast<const char*>(buf), size);
    out.close();

    std::cout << "Buffer written to output.bin\n";



    {

          // Open the file in binary mode at the end to get size
        std::ifstream infile("monster.bin", std::ios::binary | std::ios::ate);
        if (!infile) {
            std::cerr << "Failed to open file\n";
            return 1;
        }

        // Get file size
        std::streamsize size = infile.tellg();
        infile.seekg(0, std::ios::beg);

        // Allocate buffer and read content
        std::vector<uint8_t> buffer(size);
        if (!infile.read(reinterpret_cast<char*>(buffer.data()), size)) {
            std::cerr << "Failed to read file content\n";
            return 1;
        }
        uint8_t *buffer_pointer = buffer.data();

        // Get an view to the root object inside the buffer.
        // Monster monster = GetMonster(buffer_pointer);
        const Monster* monster = GetMonster(buffer_pointer);

        auto hp = monster->hp();
        auto mana = monster->mana();
        auto name = monster->name()->c_str();
        auto pos = monster->pos();
        auto x = pos->x();
        auto y = pos->y();
        auto z = pos->z();

        // flatbuffers::Vector<unsigned char> inv = monster->inventory();
        const flatbuffers::Vector<unsigned char>* inv = monster->inventory();
        auto inv_len = inv->size();
        auto third_item = inv->Get(2);

        // flatbuffers::Vector<Weapon> weapons = monster->weapons();
        const flatbuffers::Vector<flatbuffers::Offset<Weapon>>* weapons = monster->weapons();

        auto weapon_len = weapons->size();
        auto second_weapon_name = weapons->Get(1)->name()->str();
        auto second_weapon_damage = weapons->Get(1)->damage();

        auto union_type = monster->equipped_type();

        if (union_type == Equipment_Weapon) {
            // Requires `static_cast` to type `const Weapon*`.
            auto weapon = static_cast<const Weapon*>(monster->equipped());

            auto weapon_name = weapon->name()->str(); // "Axe"
            auto weapon_damage = weapon->damage();    // 5
        }

        printf("hp = %x %d\n",hp, hp);
        printf("mana = %x %d\n",mana, mana);
        printf("name = %s\n",name);
    }


}