#include "monster_builder.h" // Generated by `flatcc`.
#include <stdio.h>
#include "monster_verifier.h"
// Convenient namespace macro to manage long namespace prefix.
#undef ns
// Specified in the schema.
#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(MyGame_Sample, x) 

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

int main(){
    flatcc_builder_t builder, *B;
    B = &builder;
    // Initialize the builder object.
    flatcc_builder_init(B);

    flatbuffers_string_ref_t weapon_one_name 
        = flatbuffers_string_create_str(B, "Sword");
    flatbuffers_string_ref_t weapon_two_name 
        = flatbuffers_string_create_str(B, "Axe");


    uint16_t weapon_one_damage = 3;
    uint16_t weapon_two_damage = 5;

    ns(Weapon_ref_t) sword 
        = ns(Weapon_create(B, weapon_one_name, weapon_one_damage));
    ns(Weapon_ref_t) axe 
        = ns(Weapon_create(B, weapon_two_name, weapon_two_damage));

    // We use the internal builder stack to implement a dynamic vector.
    ns(Weapon_vec_start(B));
    ns(Weapon_vec_push(B, sword));
    ns(Weapon_vec_push(B, axe));
    ns(Weapon_vec_ref_t) weapons = ns(Weapon_vec_end(B));


    // Create a `vector` representing the inventory of the Orc. Each number
    // could correspond to an item that can be claimed after he is slain.
    uint8_t treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    flatbuffers_uint8_vec_ref_t inventory;
    // `c_vec_len` is the convenience macro we defined earlier.
    inventory = flatbuffers_uint8_vec_create(B, treasure, c_vec_len(treasure));


    // Serialize a name for our monster, called "Orc".
    // The _str suffix indicates the source is an ascii-z string.
    flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, "Orc");

    // Set his hit points to 300 and his mana to 150.
    uint16_t hp = 0xde;
    uint16_t mana = 0xad;

    // Define an equipment union. `create` calls in C has a single
    // argument for unions where C++ has both a type and a data argument.
    ns(Equipment_union_ref_t) equipped = ns(Equipment_as_Weapon(axe));
    ns(Vec3_t) pos = { 1.0f, 2.0f, 3.0f };
    ns(Monster_create_as_root(B, &pos, mana, hp, name, inventory, ns(Color_Red),
            weapons, equipped));


    uint8_t *buf;
    size_t size;

    // Allocate and extract a readable buffer from internal builder heap.
    // The returned buffer must be deallocated using `free`.
    // NOTE: Finalizing the buffer does NOT change the builder, it
    // just creates a snapshot of the builder content.
    buf = flatcc_builder_finalize_buffer(B, &size);
    FILE *fp = fopen("model.dvm", "wb");
    if(fp){
        fwrite(buf, 1, size, fp);
        fclose(fp);
    }
    else{
        perror("Error failed to open model.dvm file to write\n");
        return -1;
    }
    // use buf
    free(buf);

    // Optionally reset builder to reuse builder without deallocating
    // internal stack and heap.
    flatcc_builder_reset(B);
    // build next buffer.
    // ...

    // Cleanup.
    flatcc_builder_clear(B);


    {
        fp = fopen("model.dvm", "rb");
        if(!fp){
            perror("Error failed to open model.dvm file to read\n");
            return -1;
        }
        fseek(fp, 0, SEEK_END);
        size = ftell(fp);
        rewind(fp);
        uint8_t *buffer = malloc(size);
        if(!buffer){
            perror("Malloc allocation failed");
            fclose(fp);
            return -1;
        }
        if (fread(buffer, 1, size, fp) != size) {
            perror("Error reading file contents into buffer");
            fclose(fp);
            free(buffer);
            return -1;
        }
        if(MyGame_Sample_Monster_verify_as_root(buffer, size)){
            printf("Verified\n");
        }
        else{
            printf("Not Verified\n");
        }

        ns(Monster_table_t) monster = ns(Monster_as_root(buffer));
        uint16_t hp1 = ns(Monster_hp(monster));
        uint16_t mana1 = ns(Monster_mana(monster));
        flatbuffers_string_t name = ns(Monster_name(monster));
        printf("hp = %x %d\n",hp1, hp1);
        printf("mana = %x %d\n",mana1, mana1);
        printf("name = %s\n",name);

    }
}